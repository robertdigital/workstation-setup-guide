import json\nimport os\nfrom kubespawner.spawner import KubeSpawner\nfrom jhub_remote_user_authenticator.remote_user_auth import RemoteUserAuthenticator\n\nclass KubeFormSpawner(KubeSpawner):\n\n    # relies on HTML5 for image datalist\n    def _options_form_default(self):\n        global registry, repoName\n        return '''\n    <h4>NVAITC@SUTD Compute</h4>\n    <p>Please allocate resources responsibly<br>If your server is unable to start, it is likely that the GPU you requested for is not available.<br>Try starting a server <b>without a GPU</b> before reporting a server problem.</p>\n    <hr>\n    <label for='image'>Image</label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n    <input list=\"image\" name=\"image\" placeholder='repo/image:tag'>\n    <datalist id=\"image\">\n      <option value=\"jupyter/minimal-notebook\">\n      <option value=\"jupyter/datascience-notebook:latest\">\n      <option value=\"stepankuzmin/pytorch-notebook\">\n      <option value=\"{0}/{1}/tensorflow-1.7.0-notebook-cpu:v0.2.1\">\n      <option value=\"{0}/{1}/tensorflow-1.7.0-notebook-gpu:v0.2.1\">\n      <option value=\"{0}/{1}/tensorflow-1.8.0-notebook-cpu:v0.2.1\">\n      <option value=\"{0}/{1}/tensorflow-1.8.0-notebook-gpu:v0.2.1\">\n    </datalist>\n    <p>If image is not present, it will be pulled from Docker Hub.<br>This may take a long time to complete.</p>\n    <br/>\n    <label for='cpu_guarantee'>CPU</label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n    <input name='cpu_guarantee' placeholder='1.0'></input>\n    <p>If your work is not CPU-intensive, you can choose less than 1 CPU</p>\n    <br/>\n    <label for='mem_guarantee'>Memory</label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n    <input name='mem_guarantee' placeholder='1.0Gi'></input>\n    <br/>\n    <label for='extra_resource_limits'>Extra Resource Limits</label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n    <input name='extra_resource_limits' placeholder=''></input>\n    <p>Example: to request 2 GPUs: <code>{{&quot;nvidia.com/gpu&quot;: 2}}</code><br>Please leave this field blank for none.</p>\n    <br/>\n    <label for='node_selector'>Resource Criteria</label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n    <input name='node_selector' placeholder=''</input>\n    <p>To request specifically for V100: <code>{{&quot;accelerator&quot;: &quot;V100&quot;}}</code><br>Options: V100, GP100, or leave it blank</p>\n    <br/>\n    '''.format(registry, repoName)\n\n    def options_from_form(self, formdata):\n        options = {}\n        options['image'] = formdata.get('image', [''])[0].strip()\n        options['cpu_guarantee'] = formdata.get(\n                    'cpu_guarantee', [''])[0].strip()\n        options['mem_guarantee'] = formdata.get(\n                    'mem_guarantee', [''])[0].strip()\n        options['extra_resource_limits'] = formdata.get(\n                    'extra_resource_limits', [''])[0].strip()\n        options['node_selector'] = formdata.get(\n                    'node_selector', [''])[0].strip()\n        return options\n\n    @property\n    def singleuser_image_spec(self):\n        global cloud\n        if cloud == 'ack':\n            image = 'registry.aliyuncs.com/kubeflow-images-public/tensorflow-notebook-cpu'\n        else:\n            image = 'gcr.io/kubeflow-images-public/tensorflow-1.8.0-notebook-cpu:v0.2.1'\n        if self.user_options.get('image'):\n            image = self.user_options['image']\n        return image\n\n    @property\n    def cpu_guarantee(self):\n        cpu = '1.0'\n        if self.user_options.get('cpu_guarantee'):\n            cpu = self.user_options['cpu_guarantee']\n        return cpu\n\n    @property\n    def mem_guarantee(self):\n        mem = '1Gi'\n        if self.user_options.get('mem_guarantee'):\n            mem = self.user_options['mem_guarantee']\n        return mem\n\n    @property\n    def extra_resource_limits(self):\n        extra = ''\n        if self.user_options.get('extra_resource_limits'):\n            extra = json.loads(self.user_options['extra_resource_limits'])\n        return extra\n    \n    @property\n    def node_selector(self):\n        extra = ''\n        if self.user_options.get('node_selector'):\n            extra = json.loads(self.user_options['node_selector'])\n        return extra\n\n\n###################################################\n# JupyterHub Options\n###################################################\nc.JupyterHub.ip = '0.0.0.0'\nc.JupyterHub.hub_ip = '0.0.0.0'\n# Don't try to cleanup servers on exit - since in general for k8s, we want\n# the hub to be able to restart without losing user containers\nc.JupyterHub.cleanup_servers = False\n###################################################\n\nc.JupyterHub.services = [\n        {\n            'name': 'wget-cull-idle',\n        'admin': True,\n        'command': ['wget', 'https://raw.githubusercontent.com/jupyterhub/jupyterhub/master/examples/cull-idle/cull_idle_servers.py']\n    },\n\n    {\n            'name': 'cull-idle',\n        'admin': True,\n        'command': ['python', 'cull_idle_servers.py', '--timeout=3600']\n    }\n]\n\n###################################################\n# Spawner Options\n###################################################\ncloud = os.environ.get('CLOUD_NAME')\nregistry = os.environ.get('REGISTRY')\nrepoName = os.environ.get('REPO_NAME')\nc.JupyterHub.spawner_class = KubeFormSpawner\nc.KubeSpawner.singleuser_image_spec = '{0}/{1}/tensorflow-notebook'.format(registry, repoName)\n\nc.KubeSpawner.cmd = 'start-singleuser.sh'\nc.KubeSpawner.args = ['--allow-root']\n# gpu images are very large ~15GB. need a large timeout.\nc.KubeSpawner.start_timeout = 60 * 30\n# Increase timeout to 5 minutes to avoid HTTP 500 errors on JupyterHub\nc.KubeSpawner.http_timeout = 60 * 5\n\n# Volume setup\nc.KubeSpawner.singleuser_uid = 1000\nc.KubeSpawner.singleuser_fs_gid = 100\nc.KubeSpawner.singleuser_working_dir = '/home/jovyan'\nvolumes = []\nvolume_mounts = []\n###################################################\n# Persistent volume options\n###################################################\n# Using persistent storage requires a default storage class.\n# TODO(jlewi): Verify this works on minikube.\n# see https://github.com/kubeflow/kubeflow/pull/22#issuecomment-350500944\npvc_mount = os.environ.get('NOTEBOOK_PVC_MOUNT')\nif pvc_mount and pvc_mount != 'null':\n    c.KubeSpawner.user_storage_pvc_ensure = True\n    # How much disk space do we want?\n    c.KubeSpawner.user_storage_capacity = '10Gi'\n    c.KubeSpawner.user_storage_class = 'standard'\n    c.KubeSpawner.pvc_name_template = 'claim-{username}{servername}'\n    volumes.append(\n                {\n                    'name': 'volume-{username}{servername}',\n            'persistentVolumeClaim': {\n                        'claimName': 'claim-{username}{servername}'\n            }\n        }\n    )\n    volume_mounts.append(\n                {\n                    'mountPath': pvc_mount,\n            'name': 'volume-{username}{servername}'\n        }\n    )\n\n# ###################################################\n# ### Extra volumes for NVIDIA drivers (Azure)\n# ###################################################\n# # Temporary fix:\n# # AKS / acs-engine doesn't yet use device plugin so we have to mount the drivers to use GPU\n# # TODO(wbuchwalter): Remove once device plugin is merged\nif cloud == 'aks' or cloud == 'acsengine':\n    volumes.append({\n                'name': 'nvidia',\n        'hostPath': {\n                    'path': '/usr/local/nvidia'\n        }\n    })\n    volume_mounts.append({\n                'name': 'nvidia',\n        'mountPath': '/usr/local/nvidia'\n    })\n\nc.KubeSpawner.volumes = volumes\nc.KubeSpawner.volume_mounts = volume_mounts\n\n######## Authenticator ######\nc.JupyterHub.authenticator_class = 'dummyauthenticator.DummyAuthenticator'\n